#include <stdio.h>

int main() {

  // 비트 연산은 비트 단위에서 직접 조작하기 때문에 일반 사칙 연산 보다 빠름
  // unsigned의 경우 부호가 없지만, signed의 경우 MSB의 자리로 이동할 때 보수연산

  // shift <<: 지정한 횟수만큼 비트의 자리를 왼쪽으로 이동 // 1칸 = *2
  // 제일 왼쪽으로 밀려나는 비트는 버려지며 빈 자리는 0으로
  unsigned char a = 4 << 1; // 0000 0100 => 0000 1000 // 8
  unsigned char b = 8 << 2; // 0000 1000 => 0010 0000 // 32
  printf("4 << 1: %d\n", a);
  printf("8 << 2: %d\n", b);

  // char c = 1 << 8; // 0000 0001 => 에러남
  int d = 1 << 8; // 0000 0000 0000 0000 0000 0000 0000 0001
  // printf("(char) 1 << 8: %d\n", c); // 0000 0000
  // char의 경우 8bit이기 때문에 << 8을 수행하면 1이 잘리며 0000 0000으로 0반환
  printf("(int) 1 << 8: %d\n", d);
  // int의 경우 32bit이기 때문에 << 8을 수행하면 2^8으로 256반환

  unsigned char e = 1 << 7; // 128
  char f = 1 << 7; // -128 마지막 비트가 MSB이기 때문에 음수처리되어 보수 연산
  printf("(unsigend) 1 << 7: %d\n", e);
  printf("(signed) 1 << 7: %d\n", f);


  // shift >>: 지정한 횟수만큼 비트의 자리를 오른으로 이동 // 1칸 = /2
	unsigned char g = 4 >> 1;  // 0000 0100
	unsigned char h = 8 >> 2;  // 0000 1000
    
	printf("4 >> 1 : %d\n", g); // 2
	printf("8 >> 2 : %d\n", h); // 2
	
	g = 14 >> 3;  // 0000 1110
	h = 16 >> 4; // 0001 0000
  
	printf("14 >> 3 : %d\n", g); // 1
	printf("16 >> 4 : %d\n", h); // 1
	
	char i = -16 >> 2;  // 1111 0000
	
	printf("-16 >> 2 : %d\n", i); // -4

} 