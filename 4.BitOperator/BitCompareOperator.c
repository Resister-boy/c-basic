#include <stdio.h>


// Bit Operator는 정수나 정수로 변환 가능한 타입만 가능
// 실수, 포인터 등으로는 비트 연산을 할 수 없음
// 메모리 공간의 효율성을 높이고 연산의 수를 줄일 수 있음

// &: 두 비트 모두 1일 때 1 반환
// |: 두 비트 중 하나라도 1일 때 1 반환
// ^: 두 비트가 다르면 1을, 같으면 0 반환
// ~: 비트반전 => 피연산자가 하나이며, 한 값의 비트를 모두 반전

int main(){
  // &: 모두 1일 때 1 반환
  unsigned char a = 4; // 0000 0100
  unsigned char b = 8; // 0000 1000
  unsigned char c = a & b; // => 0
  // 각 수를 2진수로 변환한 후 비교
  // 하나도 같은 게 없기 때문에 0 반환

  printf("4 & 8: %d\n", c);

  a = 6; // 0000 0110
  b = 13; // 0000 1101
  c = a & b; // 4
  printf("6 & 13: %d\n", c);
  // 1의 자리, 2의 자리는 다르지만 4의 자리가 같으므로 4 반환
  

  // |: 하나라도 1일 때 1 반환
  unsigned char d = 4; // 0000 0100
  unsigned char e = 8; // 0000 1000
  unsigned char f = d | e; // => 12
  // 4의 자리와 8의 자리가 1이므로 12 반환

  printf("4 | 8: %d\n", f);

  d = 6; // 0000 0110
  e = 13; // 0000 1101
  f = a | b; // => 15
  // 1의 자리 2의 자리, 4의 자리, 8의 자리 모두 1이므로 15 반환

  printf("6 | 13: %d\n", f);
  // ^: 두 비트가 다르면 1, 같으면 0 반환
  unsigned char g = 4; // 0000 0100
  unsigned char h = 8; // 0000 1000
  unsigned char i = g ^ h; // => 12
  // 1의 자리와 2의 자리가 같고 4의 자리와 8의 자리가 다르므로 12 반환

  printf("4 ^ 8: %d\n", i);

  g = 6; // 0000 0110
  h = 13; // 0000 1101
  i = g ^ h; // => 11
  // 4의 자리가 같고, 1의 자리, 2의 자리, 8의 자리가 다르므로 11 반환

  printf("6 ^ 13: %d\n", i); 

  // ~: 비트 반전
	unsigned char j = 4;  // 0000 0100
	unsigned char k = 8;  // 0000 1000
	unsigned char l = ~j; // 1111 1011
	unsigned char m = ~k; // 1111 0100

  // 만일 unsigned가 아닌 sign였다면 8비트 중 Most Significant Bit(부호비트) 역시 반전됨
  // MSB는 양수일 경우 1, 음수일 경우 0
  // 때문에 8비트 중 MSB가 포함되지 않는 unsigned로 ㄱㄱ

  printf("~4, ~8: %d, %d \n", l, m);

	j = 6;  // 0000 0110
	k = 13; // 0000 1101
	l = ~j; // 1111 1001
	m = ~k; // 1111 0010

	printf("~6 ~13: %d, %d \n", l, m);

  return 0;
}